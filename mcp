#!/usr/bin/env node

/**
 * MCP CLI for Notion Vibe Coding
 * Usage: ./mcp <command> [args...]
 */

require('dotenv').config();
const fs = require('fs');
const path = require('path');
const { Client } = require('@notionhq/client');
const { SimpleProgressTracker } = require('./dist/simple-progress-tracker.js');
const { TodoManager } = require('./dist/todo-manager.js');
const { ProgressCalculator } = require('./dist/progress-calculator.js');

// Load configuration from mcp-config.json
function loadWorkflowConfig() {
  const configPath = path.join(__dirname, '.claude', 'mcp-config.json');
  
  if (!fs.existsSync(configPath)) {
    console.error('âŒ Configuration file not found: .claude/mcp-config.json');
    console.error('ğŸ’¡ Make sure you have created this file with your MCP configuration');
    process.exit(1);
  }

  try {
    console.log('ğŸ“ Loading config from .claude/mcp-config.json');
    const mcpConfig = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    const workflowConfig = mcpConfig.mcpServers?.['notion-vibe-coding']?.env?.WORKFLOW_CONFIG;
    
    if (!workflowConfig) {
      console.error('âŒ WORKFLOW_CONFIG not found in mcp-config.json');
      console.error('ğŸ’¡ Check that your config has: mcpServers.notion-vibe-coding.env.WORKFLOW_CONFIG');
      process.exit(1);
    }

    console.log('âœ… Configuration loaded successfully');
    return workflowConfig;
  } catch (error) {
    console.error(`âŒ Failed to parse mcp-config.json: ${error.message}`);
    console.error('ğŸ’¡ Check that your JSON is valid');
    process.exit(1);
  }
}

const WORKFLOW_CONFIG = loadWorkflowConfig();

class MCPWrapper {
  constructor() {
    if (!process.env.NOTION_API_KEY || !process.env.NOTION_DATABASE_ID) {
      console.error('âŒ Missing environment variables. Make sure .env file exists with:');
      console.error('   NOTION_API_KEY=your_api_key');
      console.error('   NOTION_DATABASE_ID=your_database_id');
      process.exit(1);
    }

    this.notion = new Client({ auth: process.env.NOTION_API_KEY });
    this.tracker = new SimpleProgressTracker(this.notion, WORKFLOW_CONFIG, process.env.NOTION_DATABASE_ID);
    this.todoManager = new TodoManager(this.notion);
    this.progressCalculator = new ProgressCalculator(
      { todoProgressionEnabled: true, autoProgressionThresholds: { inProgress: 1, test: 100 } },
      Object.keys(WORKFLOW_CONFIG.statusMapping),
      WORKFLOW_CONFIG.transitions
    );
  }

  async createTask(title, taskType, description) {
    try {
      console.log(`ğŸ”¨ Creating task: "${title}" (${taskType})`);
      const taskId = await this.tracker.createTask(title, taskType, description);
      console.log(`âœ… Task created successfully!`);
      console.log(`ğŸ“‹ Task ID: ${taskId}`);
      console.log(`ğŸ”— Notion URL: https://notion.so/${taskId}`);
      return { success: true, taskId };
    } catch (error) {
      console.error(`âŒ Failed to create task: ${error.message}`);
      return { success: false, error: error.message };
    }
  }

  async getTaskInfo(taskId) {
    try {
      console.log(`ğŸ” Getting task info for: ${taskId}`);
      const state = this.tracker.getWorkflowState(taskId);
      const nextStatuses = this.tracker.getNextStatuses(taskId);
      
      // Get current status from Notion
      const currentStatus = await this.tracker.readCurrentStatus(taskId);
      
      console.log(`ğŸ“Š Current Status: ${currentStatus}`);
      console.log(`ğŸ¯ Next Statuses: ${nextStatuses.join(', ')}`);
      console.log(`ğŸ·ï¸  Task Type: ${state?.taskType || 'Unknown'}`);
      
      return { success: true, currentStatus, nextStatuses, taskType: state?.taskType };
    } catch (error) {
      console.error(`âŒ Failed to get task info: ${error.message}`);
      return { success: false, error: error.message };
    }
  }

  async updateTaskStatus(taskId, newStatus, force = false) {
    try {
      console.log(`ğŸ”„ Updating task ${taskId} to status: ${newStatus}`);
      
      if (force) {
        await this.tracker.forceStatusUpdate(taskId, newStatus, 'Manual override via wrapper');
      } else {
        await this.tracker.updateTaskStatus(taskId, newStatus);
      }
      
      console.log(`âœ… Status updated successfully to: ${newStatus}`);
      return { success: true, newStatus };
    } catch (error) {
      console.error(`âŒ Failed to update status: ${error.message}`);
      return { success: false, error: error.message };
    }
  }

  async getWorkflowGuidance(action) {
    try {
      console.log(`ğŸ“– Getting workflow guidance for: ${action}`);
      const guidance = this.tracker.getWorkflowGuidance(action);
      console.log('\n' + guidance);
      return { success: true, guidance };
    } catch (error) {
      console.error(`âŒ Failed to get guidance: ${error.message}`);
      return { success: false, error: error.message };
    }
  }

  async progressTodo(taskId, todoText, completed, autoProgress = true) {
    try {
      console.log(`âœ… ${completed ? 'Completing' : 'Uncompleting'} todo: "${todoText}"`);
      
      const result = await this.todoManager.updateTodo(taskId, todoText, completed);
      const currentStatus = await this.tracker.readCurrentStatus(taskId);
      const recommendation = this.progressCalculator.calculateRecommendedStatus(currentStatus, result.stats);

      if (autoProgress && recommendation.shouldAutoProgress) {
        await this.tracker.updateTaskStatus(taskId, recommendation.recommendedStatus);
        console.log(`ğŸš€ Auto-progressed to: ${recommendation.recommendedStatus}`);
      }

      console.log(`ğŸ“Š Progress: ${result.stats.completed}/${result.stats.total} (${result.stats.percentage}%)`);
      return { success: true, stats: result.stats, autoProgressed: autoProgress && recommendation.shouldAutoProgress };
    } catch (error) {
      console.error(`âŒ Failed to progress todo: ${error.message}`);
      return { success: false, error: error.message };
    }
  }

  async analyzeTodos(taskId) {
    try {
      console.log(`ğŸ”¬ Analyzing todos for task: ${taskId}`);
      
      const analysis = await this.todoManager.extractTodosFromTask(taskId, false);
      const currentStatus = await this.tracker.readCurrentStatus(taskId);
      const recommendation = this.progressCalculator.calculateRecommendedStatus(currentStatus, analysis.stats);

      console.log(`\nğŸ“‹ Found ${analysis.stats.total} todos:`);
      analysis.todos.forEach((todo) => {
        const status = todo.completed ? 'âœ…' : 'â¬œ';
        console.log(`   ${status} ${todo.text}`);
      });
      
      console.log(`\nğŸ“Š Stats: ${analysis.stats.completed}/${analysis.stats.total} completed (${analysis.stats.percentage}%)`);
      console.log(`ğŸ’¡ Recommended status: ${recommendation.recommendedStatus}`);
      
      return { success: true, todos: analysis.todos, stats: analysis.stats, recommendation };
    } catch (error) {
      console.error(`âŒ Failed to analyze todos: ${error.message}`);
      return { success: false, error: error.message };
    }
  }

  showHelp() {
    console.log(`
ğŸš€ MCP CLI for Notion Vibe Coding

ğŸ“ TASK MANAGEMENT:
  create-task <title> <type> <description>     Create a new task
  get-task-info <taskId>                       Get task information
  update-status <taskId> <newStatus> [--force] Update task status
  
ğŸ“‹ TODO MANAGEMENT:  
  progress-todo <taskId> <todoText> <true/false> [--no-auto] Mark todo as done/undone
  analyze-todos <taskId>                       Analyze all todos in a task
  
ğŸ“– WORKFLOW:
  get-guidance <action>                        Get workflow guidance (creation/update/execution)
  
ğŸ› ï¸  UTILITIES:
  help                                         Show this help
  
ğŸ“š EXAMPLES:
  ./mcp create-task "Fix login bug" "Bug" "Users can't login with Gmail"
  ./mcp get-task-info 23e0da7a-7a07-8145-9611-e394062d8a55
  ./mcp update-status <taskId> inProgress
  ./mcp progress-todo <taskId> "Write unit tests" true
  ./mcp analyze-todos <taskId>
  ./mcp get-guidance creation

ğŸ·ï¸  TASK TYPES: Feature, Bug, Refactoring
ğŸ”„ STATUSES: notStarted, inProgress, test, done
`);
  }
}

// Main execution
async function main() {
  const [,, command, ...args] = process.argv;

  if (!command || command === 'help' || command === '--help' || command === '-h') {
    new MCPWrapper().showHelp();
    return;
  }

  const wrapper = new MCPWrapper();

  try {
    switch (command) {
      case 'create-task':
        if (args.length < 3) {
          console.error('âŒ Usage: create-task <title> <type> <description>');
          process.exit(1);
        }
        await wrapper.createTask(args[0], args[1], args[2]);
        break;

      case 'get-task-info':
        if (args.length < 1) {
          console.error('âŒ Usage: get-task-info <taskId>');
          process.exit(1);
        }
        await wrapper.getTaskInfo(args[0]);
        break;

      case 'update-status':
        if (args.length < 2) {
          console.error('âŒ Usage: update-status <taskId> <newStatus> [--force]');
          process.exit(1);
        }
        const force = args.includes('--force');
        await wrapper.updateTaskStatus(args[0], args[1], force);
        break;

      case 'progress-todo':
        if (args.length < 3) {
          console.error('âŒ Usage: progress-todo <taskId> <todoText> <true/false> [--no-auto]');
          process.exit(1);
        }
        const autoProgress = !args.includes('--no-auto');
        const completed = args[2].toLowerCase() === 'true';
        await wrapper.progressTodo(args[0], args[1], completed, autoProgress);
        break;

      case 'analyze-todos':
        if (args.length < 1) {
          console.error('âŒ Usage: analyze-todos <taskId>');
          process.exit(1);
        }
        await wrapper.analyzeTodos(args[0]);
        break;

      case 'get-guidance':
        if (args.length < 1) {
          console.error('âŒ Usage: get-guidance <action> (creation/update/execution)');
          process.exit(1);
        }
        await wrapper.getWorkflowGuidance(args[0]);
        break;

      default:
        console.error(`âŒ Unknown command: ${command}`);
        console.error('ğŸ’¡ Run "./mcp help" to see available commands');
        process.exit(1);
    }
  } catch (error) {
    console.error(`ğŸ’¥ Unexpected error: ${error.message}`);
    process.exit(1);
  }
}

main();